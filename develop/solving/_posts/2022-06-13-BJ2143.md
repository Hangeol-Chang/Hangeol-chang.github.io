---
layout: post
title: 백준 2143 두 배열의 합 [자바]
hide_last_modified: true
---

> java

## 문제 분석

- 두 배열이 주어진다
- 두 배열의 부분합의 합으로, 목표한 수를 만드려고 한다.
- 이 때 가능한 경우의 수는?



### 입력조건

```
목표 수 T
배열 a의 크기 n
배열 a 숫자 배열
배열 b의 크기 m
배열 b 숫자 배열
```



## 풀이과정

- 문제 알고리즘 분류에 이분탐색이 써져 있는데, 나는 도저히 이 문제를 이분탐색으로 풀 방법이 떠오르지 않았다.
- 그래서 이 문제를 푸는 데에 우선, a와 b에서 구할 수 있는 부분합을 전부 추출한 후,
- 구해진 두 개의 배열을 b는 내림차순으로, a는 오름차순으로 정렬하여, 투포인터를 변형하여 계산하였다.
- a의 부분합 배열에 포인터1, b의 부분합 배열에 포인터2를 두고,
- a[a_pointer] + b[b_pointer]를 계산하여, 이 값이 목표보다 크다면 b포인터를 올리고, 목표보다 작다면 a포인터를 올려가며 포인터가 배열의 끝의 도달할 때 까지 계산하였다.



##### ps

- 문제를 풀고 



## 코드 구성

- 아리스토테네스의 체

  ```java
  int sqnum = (int) Math.sqrt(num);
  for( int i = 2; i <= sqnum; i++) {
      if(a[i]) continue;
      a[i] = true;
      nums.add(i);
  
      int idf = i * i;
      while(idf <= num) {
          a[idf] = true;
          idf += i;
      }
  }
  int ii = sqnum+1;
  while(true) {
      if(!a[ii]) {
          if( ii < num) nums.add(ii);
          if(ii > num/2)
              break;
      }
      ii++;
  }
  ```

- 투포인터

  ```java
  int anscount = 0;
  int l = 0;
  int r = 0;
  int sum = nums.get(0);
  while( r < nums.size()-1 ) {
      if(sum < num) 	   sum += nums.get(++r);
      else {
          if (sum == num) anscount++;
          sum -= nums.get(l++);
      }
  }
  
  while(l <= r && sum >= num) {
      if(sum == num) anscount++;
      sum -= nums.get(l++);
  }
  ```

  



## 전체 코드

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class BJ1644_소수의연속합 {
	public static void main(String[] args) throws IOException {
		int num = Integer.parseInt(new BufferedReader(new InputStreamReader(System.in)).readLine());
		
		boolean[] a = new boolean[num+2];
		a[1] = true;
		ArrayList<Integer> nums = new ArrayList<>();
		
		// 소수 가져오기.
		int sqnum = (int) Math.sqrt(num);
		for( int i = 2; i <= sqnum; i++) {
			if(a[i]) continue;
			a[i] = true;
			nums.add(i);
			
			int idf = i * i;
			while(idf <= num) {
				a[idf] = true;
				idf += i;
			}
		}
		int ii = sqnum+1;
		while(true) {
			if(!a[ii]) {
				if( ii < num) nums.add(ii);
				if(ii > num/2)
					break;
			}
			ii++;
		}
		
		// 투포인터
		int anscount = 0;
		if(nums.size() > 0) {
			int l = 0;
			int r = 0;
			int sum = nums.get(0);
			while( r < nums.size()-1 ) {
				if(sum < num) 	   sum += nums.get(++r);
				else {
					if (sum == num) anscount++;
					sum -= nums.get(l++);
				}
			}
			
			while(l <= r && sum >= num) {
				if(sum == num) anscount++;
				sum -= nums.get(l++);
			}
		}
		// num이 소수일 때
		if(!a[num]) anscount++;
		System.out.println(anscount);
	}
}
```

